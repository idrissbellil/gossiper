// Code generated by ent, DO NOT EDIT.

package job

import (
	"fmt"
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

const (
	// Label holds the string label denoting the job type in the database.
	Label = "job"
	// FieldID holds the string denoting the id field in the database.
	FieldID = "id"
	// FieldEmail holds the string denoting the email field in the database.
	FieldEmail = "email"
	// FieldFromRegex holds the string denoting the from_regex field in the database.
	FieldFromRegex = "from_regex"
	// FieldURL holds the string denoting the url field in the database.
	FieldURL = "url"
	// FieldMethod holds the string denoting the method field in the database.
	FieldMethod = "method"
	// FieldHeaders holds the string denoting the headers field in the database.
	FieldHeaders = "headers"
	// FieldPayloadTemplate holds the string denoting the payload_template field in the database.
	FieldPayloadTemplate = "payload_template"
	// FieldIsActive holds the string denoting the is_active field in the database.
	FieldIsActive = "is_active"
	// FieldCreatedAt holds the string denoting the created_at field in the database.
	FieldCreatedAt = "created_at"
	// EdgeUser holds the string denoting the user edge name in mutations.
	EdgeUser = "user"
	// Table holds the table name of the job in the database.
	Table = "jobs"
	// UserTable is the table that holds the user relation/edge.
	UserTable = "jobs"
	// UserInverseTable is the table name for the User entity.
	// It exists in this package in order to avoid circular dependency with the "user" package.
	UserInverseTable = "users"
	// UserColumn is the table column denoting the user relation/edge.
	UserColumn = "job_user"
)

// Columns holds all SQL columns for job fields.
var Columns = []string{
	FieldID,
	FieldEmail,
	FieldFromRegex,
	FieldURL,
	FieldMethod,
	FieldHeaders,
	FieldPayloadTemplate,
	FieldIsActive,
	FieldCreatedAt,
}

// ForeignKeys holds the SQL foreign-keys that are owned by the "jobs"
// table and are not defined as standalone fields in the schema.
var ForeignKeys = []string{
	"job_user",
}

// ValidColumn reports if the column name is valid (part of the table columns).
func ValidColumn(column string) bool {
	for i := range Columns {
		if column == Columns[i] {
			return true
		}
	}
	for i := range ForeignKeys {
		if column == ForeignKeys[i] {
			return true
		}
	}
	return false
}

var (
	// EmailValidator is a validator for the "email" field. It is called by the builders before save.
	EmailValidator func(string) error
	// DefaultFromRegex holds the default value on creation for the "from_regex" field.
	DefaultFromRegex string
	// URLValidator is a validator for the "url" field. It is called by the builders before save.
	URLValidator func(string) error
	// DefaultIsActive holds the default value on creation for the "is_active" field.
	DefaultIsActive bool
	// DefaultCreatedAt holds the default value on creation for the "created_at" field.
	DefaultCreatedAt func() time.Time
)

// Method defines the type for the "method" enum field.
type Method string

// MethodGET is the default value of the Method enum.
const DefaultMethod = MethodGET

// Method values.
const (
	MethodGET    Method = "GET"
	MethodPOST   Method = "POST"
	MethodPUT    Method = "PUT"
	MethodDELETE Method = "DELETE"
	MethodPATCH  Method = "PATCH"
)

func (m Method) String() string {
	return string(m)
}

// MethodValidator is a validator for the "method" field enum values. It is called by the builders before save.
func MethodValidator(m Method) error {
	switch m {
	case MethodGET, MethodPOST, MethodPUT, MethodDELETE, MethodPATCH:
		return nil
	default:
		return fmt.Errorf("job: invalid enum value for method field: %q", m)
	}
}

// OrderOption defines the ordering options for the Job queries.
type OrderOption func(*sql.Selector)

// ByID orders the results by the id field.
func ByID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldID, opts...).ToFunc()
}

// ByEmail orders the results by the email field.
func ByEmail(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldEmail, opts...).ToFunc()
}

// ByFromRegex orders the results by the from_regex field.
func ByFromRegex(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldFromRegex, opts...).ToFunc()
}

// ByURL orders the results by the url field.
func ByURL(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldURL, opts...).ToFunc()
}

// ByMethod orders the results by the method field.
func ByMethod(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldMethod, opts...).ToFunc()
}

// ByPayloadTemplate orders the results by the payload_template field.
func ByPayloadTemplate(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldPayloadTemplate, opts...).ToFunc()
}

// ByIsActive orders the results by the is_active field.
func ByIsActive(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldIsActive, opts...).ToFunc()
}

// ByCreatedAt orders the results by the created_at field.
func ByCreatedAt(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCreatedAt, opts...).ToFunc()
}

// ByUserField orders the results by user field.
func ByUserField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newUserStep(), sql.OrderByField(field, opts...))
	}
}
func newUserStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(UserInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, false, UserTable, UserColumn),
	)
}
